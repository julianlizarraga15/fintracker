<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Fintracker | Valuations</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #0f1117;
        color: #f4f6fb;
        --panel-bg: rgba(255, 255, 255, 0.04);
        --panel-border: rgba(255, 255, 255, 0.08);
        --text-muted: rgba(244, 246, 251, 0.65);
        --accent: #72e4ff;
        --danger: #ff6b6b;
        --success: #6bffa8;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at 20% -10%, rgba(114, 228, 255, 0.2), transparent 45%),
          radial-gradient(circle at 80% 0%, rgba(107, 255, 168, 0.15), transparent 35%),
          #05060a;
      }

      .app {
        max-width: 1200px;
        margin: 0 auto;
        padding: 40px 24px 80px;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .panel {
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 20px;
        padding: 24px;
        backdrop-filter: blur(20px);
        box-shadow: 0 25px 60px rgba(0, 0, 0, 0.35);
      }

      .app__header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
      }

      h1 {
        margin: 0;
        font-size: 2rem;
      }

      .subtitle {
        color: var(--text-muted);
        margin-top: 6px;
      }

      .status-chip {
        border-radius: 999px;
        padding: 8px 16px;
        font-size: 0.9rem;
        border: 1px solid var(--panel-border);
        background: rgba(255, 255, 255, 0.04);
      }

      .status-chip[data-state="loading"] {
        border-color: var(--accent);
        color: var(--accent);
      }

      .status-chip[data-state="error"] {
        border-color: var(--danger);
        color: var(--danger);
      }

      .status-chip[data-state="ready"] {
        border-color: var(--success);
        color: var(--success);
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      label {
        font-weight: 600;
      }

      .control {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      input[type="text"],
      input[type="password"] {
        flex: 1;
        min-width: 200px;
        border-radius: 14px;
        border: 1px solid var(--panel-border);
        padding: 14px 16px;
        font-size: 1rem;
        background: rgba(0, 0, 0, 0.25);
        color: inherit;
      }

      input[type="text"]:focus-visible,
      input[type="password"]:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      button {
        border: none;
        border-radius: 14px;
        padding: 14px 22px;
        font-size: 1rem;
        background: linear-gradient(120deg, #7ef6de, #72e4ff);
        color: #05111b;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        box-shadow: 0 15px 25px rgba(114, 228, 255, 0.3);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
      }

      button:not(:disabled):hover {
        transform: translateY(-1px);
      }

      .hint {
        margin: 0;
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .message {
        margin-top: 8px;
        font-size: 0.95rem;
      }

      .message[data-tone="error"] {
        color: var(--danger);
      }

      .auth-grid {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      }

      .login-status {
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .message[data-tone="success"] {
        color: var(--success);
      }

      .meta-grid {
        margin-top: 20px;
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }

      .label {
        display: block;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-muted);
        margin-bottom: 6px;
      }

      .value-large {
        font-size: 1.6rem;
        font-weight: 600;
      }

      .totals {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 18px;
        margin-top: 20px;
      }

      .table-wrapper {
        margin-top: 20px;
        border-radius: 16px;
        border: 1px solid var(--panel-border);
        overflow: hidden;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.95rem;
      }

      thead {
        background: rgba(255, 255, 255, 0.05);
      }

      th,
      td {
        padding: 14px 16px;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      tbody tr:hover {
        background: rgba(255, 255, 255, 0.03);
      }

      .mono {
        font-family: "JetBrains Mono", "SFMono-Regular", Consolas, monospace;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        border-radius: 999px;
        padding: 4px 10px;
        border: 1px solid var(--panel-border);
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .badge[data-tone="ok"] {
        color: var(--success);
        border-color: rgba(107, 255, 168, 0.5);
      }

      .badge[data-tone="warning"] {
        color: #ffd66b;
        border-color: rgba(255, 214, 107, 0.5);
      }

      .toggle-button {
        background: none;
        border: 1px solid var(--panel-border);
        color: var(--accent);
        padding: 4px 8px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.85rem;
        line-height: 1;
      }

      .details-row {
        background: rgba(255, 255, 255, 0.02);
      }

      .details-row table {
        margin-top: 8px;
        font-size: 0.9rem;
      }

      .details-row td {
        border-bottom: none;
      }

      .is-hidden {
        display: none;
      }

      .empty-state {
        text-align: center;
        padding: 40px;
        color: var(--text-muted);
      }

      .sparkline {
        width: 120px;
        height: 36px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: var(--text-muted);
        gap: 4px;
      }

      .sparkline svg {
        width: 100%;
        height: 100%;
      }

      .sparkline__line {
        fill: none;
        stroke: var(--accent);
        stroke-width: 2;
      }

      .sparkline__area {
        fill: rgba(114, 228, 255, 0.22);
        stroke: none;
      }

      .sparkline__placeholder {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .sparkline--interactive {
        cursor: pointer;
      }

      .sparkline--muted {
        opacity: 0.65;
      }

      .modal {
        position: fixed;
        inset: 0;
        z-index: 50;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
        background: rgba(0, 0, 0, 0.55);
      }

      .modal.is-hidden {
        display: none;
      }

      .modal__dialog {
        width: min(92vw, 820px);
        background: rgba(5, 6, 10, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        padding: 18px;
        box-shadow: 0 25px 70px rgba(0, 0, 0, 0.6);
      }

      .modal__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
      }

      .modal__title {
        margin: 0;
        font-size: 1.15rem;
      }

      .modal__subtitle {
        color: var(--text-muted);
        margin-top: 4px;
        font-size: 0.95rem;
      }

      .modal__body {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .modal__chart {
        background: rgba(5, 6, 10, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 12px;
        position: relative;
      }

      .modal__chart svg {
        width: 100%;
        height: 200px;
        background: rgba(5, 6, 10, 0.9);
        border-radius: 10px;
      }

      .chart-axis {
        stroke: rgba(255, 255, 255, 0.14);
        stroke-width: 1;
      }

      .chart-grid {
        stroke: rgba(255, 255, 255, 0.06);
        stroke-width: 1;
      }

      .chart-tick {
        fill: var(--text-muted);
        font-size: 10px;
      }

      .chart-dot {
        fill: var(--accent);
        stroke: rgba(5, 6, 10, 0.9);
        stroke-width: 1.5;
        opacity: 0.9;
        transition: r 0.1s ease, opacity 0.1s ease;
      }

      .chart-dot.is-highlighted {
        opacity: 1;
        r: 4.5;
      }

      .chart-tooltip {
        position: absolute;
        background: rgba(5, 6, 10, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 0.9rem;
        color: #f4f6fb;
        pointer-events: none;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
        display: none;
        white-space: nowrap;
      }

      .chart-tooltip.is-visible {
        display: block;
      }

      .modal__meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .modal__sources {
        color: var(--text-muted);
        font-size: 0.95rem;
      }

      .modal__alert {
        color: var(--danger);
        font-size: 0.9rem;
        display: none;
      }

      .modal__alert.is-visible {
        display: block;
      }

      .modal__close {
        background: none;
        color: inherit;
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        padding: 8px 12px;
        cursor: pointer;
      }

      .modal__close:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      @media (max-width: 700px) {
        .app__header {
          flex-direction: column;
          align-items: flex-start;
        }

        table {
          font-size: 0.85rem;
        }
      }
    </style>
  </head>
  <body>
    <main class="app">
      <section class="panel">
        <div class="app__header">
          <div>
            <h1>Fintracker</h1>
          </div>
          <div class="status-chip" id="status-chip" data-state="idle">Idle</div>
        </div>
      </section>

      <section class="panel">
        <form id="login-form">
          <label for="login-username">Demo login</label>
          <div class="auth-grid">
            <input id="login-username" type="text" placeholder="Username" autocomplete="username" required />
            <input
              id="login-password"
              type="password"
              placeholder="Password"
              autocomplete="current-password"
              required
            />
            <button type="submit" id="login-btn">Log in</button>
          </div>
          <p class="login-status" id="login-feedback">Sign in to load valuation snapshots.</p>
        </form>
      </section>

      <section class="panel">
        <form id="account-form">
          <label for="account-id">Account ID</label>
          <div class="control">
            <input id="account-id" name="account" type="text" placeholder="e.g. 8e9d4d54f0b7" required />
            <button type="submit" id="load-btn">Load snapshot</button>
          </div>
          <p class="hint">Enter an account id to load its snapshot.</p>
          <div class="message" id="feedback" role="status" aria-live="polite"></div>
        </form>

        <div class="meta-grid">
          <div>
            <span class="label">Snapshot date</span>
            <div class="value-large" id="snapshot-date">—</div>
          </div>
          <div>
            <span class="label">Computed at</span>
            <div class="value-large" id="computed-ts">—</div>
          </div>
          <div>
            <span class="label">Account</span>
            <div class="value-large mono" id="account-label">—</div>
          </div>
        </div>

        <div class="totals">
          <div>
            <span class="label">Total value</span>
            <div class="value-large" id="total-value">—</div>
            <div class="hint" id="base-currency">Base currency —</div>
          </div>
          <div>
            <span class="label">Positions</span>
            <div class="value-large" id="positions-count">—</div>
            <div class="hint" id="ok-positions">OK positions —</div>
          </div>
        </div>
      </section>

      <section class="panel">
        <header>
          <h2 style="margin: 0">Positions</h2>
          <p class="hint" id="rows-summary">No snapshot loaded yet.</p>
        </header>
        <div class="table-wrapper" role="region" aria-live="polite">
          <table>
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Trend</th>
                <th>Source</th>
                <th>Unit price (USD)</th>
                <th>Quantity</th>
                <th>Value (USD)</th>
                <th>% of portfolio</th>
              </tr>
            </thead>
            <tbody id="rows-body">
              <tr>
                <td colspan="7" class="empty-state">Enter an account id and load a snapshot to see positions.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </main>

    <div class="modal is-hidden" id="history-modal" role="dialog" aria-modal="true" aria-labelledby="history-modal-title">
      <div class="modal__dialog">
        <div class="modal__header">
          <div>
            <h3 class="modal__title" id="history-modal-title">Price history</h3>
            <div class="modal__subtitle" id="history-modal-subtitle">Select a symbol to view details.</div>
          </div>
          <button type="button" class="modal__close" id="history-modal-close" aria-label="Close price history">
            ×
          </button>
        </div>
        <div class="modal__body">
          <div class="modal__alert" id="history-modal-alert">FX missing for some points.</div>
          <div class="modal__chart" id="history-modal-chart">
            <div class="sparkline__placeholder">Select a sparkline to view a larger chart.</div>
          </div>
          <div class="modal__meta">
            <div>
              <span class="label">Sources</span>
              <div class="modal__sources" id="history-modal-sources">—</div>
            </div>
            <div class="modal__actions">
              <button type="button" class="toggle-button" id="history-modal-toggle">Show native currency</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const dom = {
        statusChip: document.getElementById("status-chip"),
        feedback: document.getElementById("feedback"),
        snapshotDate: document.getElementById("snapshot-date"),
        computedTs: document.getElementById("computed-ts"),
        accountLabel: document.getElementById("account-label"),
        totalValue: document.getElementById("total-value"),
        baseCurrency: document.getElementById("base-currency"),
        positionsCount: document.getElementById("positions-count"),
        okPositions: document.getElementById("ok-positions"),
        rowsBody: document.getElementById("rows-body"),
        rowsSummary: document.getElementById("rows-summary"),
        accountInput: document.getElementById("account-id"),
        submitButton: document.getElementById("load-btn"),
        form: document.getElementById("account-form"),
        loginForm: document.getElementById("login-form"),
        loginFeedback: document.getElementById("login-feedback"),
        loginButton: document.getElementById("login-btn"),
        loginUsername: document.getElementById("login-username"),
        loginPassword: document.getElementById("login-password"),
        historyModal: document.getElementById("history-modal"),
        historyModalTitle: document.getElementById("history-modal-title"),
        historyModalSubtitle: document.getElementById("history-modal-subtitle"),
        historyModalAlert: document.getElementById("history-modal-alert"),
        historyModalChart: document.getElementById("history-modal-chart"),
        historyModalSources: document.getElementById("history-modal-sources"),
        historyModalToggle: document.getElementById("history-modal-toggle"),
        historyModalClose: document.getElementById("history-modal-close"),
      };

      const STORAGE_KEY = "fintracker.accountId";
      const REQUEST_TIMEOUT_MS = 30_000;
      const PERCENT_SCALE = 100;
      const TABLE_COLUMN_COUNT = 7;
      const PRICE_HISTORY_WINDOW_DAYS = 30;
      const SPARKLINE_WIDTH = 120;
      const SPARKLINE_HEIGHT = 36;
      const DETAIL_CHART_WIDTH = 760;
      const DETAIL_CHART_HEIGHT = 200;
      const priceHistoryCache = new Map();
      const chartState = { mode: "base", symbol: null, history: null };
      let lastBaseCurrency = "";

      const authState = {
        token: null,
        expiresAt: 0,
      };

      function setStatus(text, state = "idle") {
        dom.statusChip.textContent = text;
        dom.statusChip.dataset.state = state;
      }

      function setFeedback(message = "", tone = "") {
        dom.feedback.textContent = message;
        if (message) {
          dom.feedback.dataset.tone = tone;
        } else {
          delete dom.feedback.dataset.tone;
        }
      }

      function setLoginFeedback(message = "", tone = "") {
        dom.loginFeedback.textContent = message;
        if (tone) {
          dom.loginFeedback.dataset.tone = tone;
        } else {
          delete dom.loginFeedback.dataset.tone;
        }
      }

      function hasValidToken() {
        return Boolean(authState.token && authState.expiresAt > Date.now());
      }

      function clearAuthState(message) {
        authState.token = null;
        authState.expiresAt = 0;
        priceHistoryCache.clear();
        lastBaseCurrency = "";
        if (message) {
          setLoginFeedback(message, "error");
        }
        dom.loginPassword.value = "";
      }

      async function authenticate(username, password) {
        dom.loginButton.disabled = true;
        setLoginFeedback("Authenticating…");
        try {
          const response = await fetch("/api/auth/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ username, password }),
          });
          const payload = await response.json().catch(() => ({}));
          if (!response.ok) {
            const detail = payload && payload.detail;
            throw new Error(detail || "Login failed.");
          }
          authState.token = payload.access_token;
          const expiresInSeconds = Number(payload.expires_in) || 0;
          authState.expiresAt = Date.now() + expiresInSeconds * 1000;
          setLoginFeedback("Authenticated.", "success");
          setStatus("Authenticated", "ready");
          const detectedAccountId = (payload.account_id || "").trim();
          let accountIdToLoad = dom.accountInput.value.trim();
          if (!accountIdToLoad && detectedAccountId) {
            dom.accountInput.value = detectedAccountId;
            localStorage.setItem(STORAGE_KEY, detectedAccountId);
            setFeedback("Detected account id from login. Loading snapshot…", "success");
            accountIdToLoad = detectedAccountId;
          }
          if (accountIdToLoad) {
            loadSnapshot(accountIdToLoad);
          } else {
            setFeedback("Authenticated. Enter an account id to load a snapshot.");
          }
        } catch (error) {
          clearAuthState();
          setStatus("Auth failed", "error");
          setLoginFeedback(error.message || "Failed to authenticate.", "error");
          dom.loginUsername.focus();
        } finally {
          dom.loginButton.disabled = false;
        }
      }

      function ensureAuthenticated() {
        if (hasValidToken()) {
          return true;
        }
        clearAuthState("Session missing or expired. Log in to continue.");
        dom.loginUsername.focus();
        return false;
      }

      function formatDate(value) {
        if (!value) return "—";
        const date = new Date(value);
        if (Number.isNaN(date)) return value;
        return date.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
      }

      function formatDateTime(value) {
        if (!value) return "—";
        const date = new Date(value);
        if (Number.isNaN(date)) return value;
        return date.toLocaleString(undefined, {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });
      }

      function formatNumber(value, options = {}) {
        if (value === null || value === undefined || Number.isNaN(value)) return "—";
        return new Intl.NumberFormat(undefined, { maximumFractionDigits: 2, ...options }).format(value);
      }

      function formatCurrency(value, currency) {
        if (value === null || value === undefined || Number.isNaN(value)) return "—";
        try {
          return new Intl.NumberFormat(undefined, {
            style: "currency",
            currency,
            maximumFractionDigits: value >= 1000 ? 0 : 2,
          }).format(value);
        } catch (_) {
          return `${formatNumber(value)} ${currency ?? ""}`.trim();
        }
      }

      function formatPercent(value, fractionDigits = 2) {
        if (value === null || value === undefined || Number.isNaN(value)) return "—";
        return `${formatNumber(value, {
          minimumFractionDigits: fractionDigits,
          maximumFractionDigits: fractionDigits,
        })}%`;
      }

      function renderSparklinePlaceholder(container, text, muted = false) {
        if (!container) return;
        container.classList.toggle("sparkline--muted", muted);
        container.classList.remove("sparkline--interactive");
        container.innerHTML = `<span class="sparkline__placeholder">${text}</span>`;
      }

      function valuesForHistory(history, useBaseCurrency = true) {
        if (!history || !Array.isArray(history.prices)) {
          return { values: [], dates: [], currencies: [] };
        }
        const base = (history.base_currency || lastBaseCurrency || "").toUpperCase();
        const values = [];
        const dates = [];
        const currencies = [];
        history.prices.forEach((point) => {
          const priceBase = point.price_base;
          const currency = (point.currency || "").toUpperCase();
          const value =
            useBaseCurrency && priceBase !== null && priceBase !== undefined
              ? priceBase
              : !useBaseCurrency
              ? point.price
              : currency === base
              ? point.price
              : null;
          if (value === null || value === undefined || Number.isNaN(value)) {
            return;
          }
          values.push(Number(value));
          dates.push(point.asof_dt || point.asof_ts || "");
          currencies.push(useBaseCurrency ? base : currency || "");
        });
        return { values, dates, currencies };
      }

      function buildSparkline(values, width = SPARKLINE_WIDTH, height = SPARKLINE_HEIGHT) {
        if (!values.length) return null;
        const min = Math.min(...values);
        const max = Math.max(...values);
        const range = max - min || 1;
        const step = values.length > 1 ? width / (values.length - 1) : width;
        const points = values.map((val, idx) => {
          const x = idx * step;
          const y = height - ((val - min) / range) * height;
          return { x, y };
        });
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
        const area = document.createElementNS(svg.namespaceURI, "path");
        const bg = document.createElementNS(svg.namespaceURI, "rect");
        bg.setAttribute("x", "0");
        bg.setAttribute("y", "0");
        bg.setAttribute("width", String(width));
        bg.setAttribute("height", String(height));
        bg.setAttribute("fill", "rgba(5, 6, 10, 0.9)");
        const areaPath = [
          `M 0 ${height}`,
          ...points.map((p) => `L ${p.x} ${p.y}`),
          `L ${points[points.length - 1].x} ${height}`,
          "Z",
        ].join(" ");
        area.setAttribute("d", areaPath);
        area.setAttribute("class", "sparkline__area");
        const path = document.createElementNS(svg.namespaceURI, "path");
        path.setAttribute("d", `M ${points.map((p) => `${p.x} ${p.y}`).join(" L ")}`);
        path.setAttribute("class", "sparkline__line");
        svg.append(bg, area, path);
        return svg;
      }

      function formatAxisDateLabel(value) {
        if (!value) return "";
        const date = new Date(value);
        if (!Number.isNaN(date)) {
          return date.toLocaleDateString(undefined, { month: "short", day: "numeric" });
        }
        return String(value);
      }

      function buildDetailChart(values, dates, currencies, width = DETAIL_CHART_WIDTH, height = DETAIL_CHART_HEIGHT) {
        if (!values.length) return null;
        const margin = { top: 10, right: 14, bottom: 32, left: 64 };
        const innerWidth = Math.max(width - margin.left - margin.right, 1);
        const innerHeight = Math.max(height - margin.top - margin.bottom, 1);
        const min = Math.min(...values);
        const max = Math.max(...values);
        const baseRange = max - min || 1;
        const yPadding = baseRange * 0.08;
        const yMin = min - yPadding;
        const yMax = max + yPadding;
        const yRange = yMax - yMin || 1;
        const step = values.length > 1 ? innerWidth / (values.length - 1) : innerWidth;
        const points = values.map((val, idx) => {
          const x = margin.left + idx * step;
          const y = margin.top + innerHeight - ((val - yMin) / yRange) * innerHeight;
          return { x, y, value: val, date: dates[idx], currency: currencies?.[idx] };
        });

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

        const bg = document.createElementNS(svg.namespaceURI, "rect");
        bg.setAttribute("x", "0");
        bg.setAttribute("y", "0");
        bg.setAttribute("width", String(width));
        bg.setAttribute("height", String(height));
        bg.setAttribute("fill", "rgba(5, 6, 10, 0.9)");
        svg.appendChild(bg);

        const axisGroup = document.createElementNS(svg.namespaceURI, "g");
        const xAxisY = margin.top + innerHeight;
        const xAxis = document.createElementNS(svg.namespaceURI, "line");
        xAxis.setAttribute("x1", String(margin.left));
        xAxis.setAttribute("x2", String(width - margin.right));
        xAxis.setAttribute("y1", String(xAxisY));
        xAxis.setAttribute("y2", String(xAxisY));
        xAxis.setAttribute("class", "chart-axis");
        axisGroup.appendChild(xAxis);

        const yAxis = document.createElementNS(svg.namespaceURI, "line");
        yAxis.setAttribute("x1", String(margin.left));
        yAxis.setAttribute("x2", String(margin.left));
        yAxis.setAttribute("y1", String(margin.top));
        yAxis.setAttribute("y2", String(xAxisY));
        yAxis.setAttribute("class", "chart-axis");
        axisGroup.appendChild(yAxis);

        const yTickCount = 4;
        for (let i = 0; i <= yTickCount; i += 1) {
          const ratio = i / yTickCount;
          const y = margin.top + innerHeight - ratio * innerHeight;
          const grid = document.createElementNS(svg.namespaceURI, "line");
          grid.setAttribute("x1", String(margin.left));
          grid.setAttribute("x2", String(width - margin.right));
          grid.setAttribute("y1", String(y));
          grid.setAttribute("y2", String(y));
          grid.setAttribute("class", "chart-grid");
          axisGroup.appendChild(grid);

          const label = document.createElementNS(svg.namespaceURI, "text");
          label.setAttribute("x", String(margin.left - 8));
          label.setAttribute("y", String(y + 3));
          label.setAttribute("class", "chart-tick");
          label.setAttribute("text-anchor", "end");
          const tickValue = yMin + yRange * ratio;
          const fractionDigits = Math.abs(tickValue) >= 100 ? 0 : 2;
          label.textContent = formatNumber(tickValue, { maximumFractionDigits: fractionDigits });
          axisGroup.appendChild(label);
        }

        const xTickCount = Math.min(5, points.length);
        for (let i = 0; i < xTickCount; i += 1) {
          const ratio = xTickCount === 1 ? 0 : i / (xTickCount - 1);
          const index = Math.round((points.length - 1) * ratio);
          const point = points[index];
          if (!point) continue;
          const tick = document.createElementNS(svg.namespaceURI, "text");
          tick.setAttribute("x", String(point.x));
          tick.setAttribute("y", String(xAxisY + 14));
          tick.setAttribute("class", "chart-tick");
          tick.setAttribute("text-anchor", "middle");
          tick.textContent = formatAxisDateLabel(dates[index]);
          axisGroup.appendChild(tick);
        }

        svg.appendChild(axisGroup);

        const area = document.createElementNS(svg.namespaceURI, "path");
        const baseY = xAxisY;
        const areaPath = [
          `M ${margin.left} ${baseY}`,
          ...points.map((p) => `L ${p.x} ${p.y}`),
          `L ${points[points.length - 1].x} ${baseY}`,
          "Z",
        ].join(" ");
        area.setAttribute("d", areaPath);
        area.setAttribute("class", "sparkline__area");

        const path = document.createElementNS(svg.namespaceURI, "path");
        path.setAttribute("d", `M ${points.map((p) => `${p.x} ${p.y}`).join(" L ")}`);
        path.setAttribute("class", "sparkline__line");

        const dotsGroup = document.createElementNS(svg.namespaceURI, "g");
        points.forEach((point, idx) => {
          const dot = document.createElementNS(svg.namespaceURI, "circle");
          dot.setAttribute("cx", String(point.x));
          dot.setAttribute("cy", String(point.y));
          dot.setAttribute("r", "3");
          dot.setAttribute("class", "chart-dot");
          dot.dataset.index = String(idx);
          dotsGroup.appendChild(dot);
        });

        svg.append(area, path, dotsGroup);
        return { svg, points };
      }

      function attachChartTooltip(container, svg, points, history, useBaseCurrency) {
        if (!container || !svg || !points.length) return;
        const tooltip = document.createElement("div");
        tooltip.className = "chart-tooltip";
        container.appendChild(tooltip);
        const dots = Array.from(svg.querySelectorAll(".chart-dot"));
        const viewBox = svg.viewBox.baseVal;
        const baseLabel = (history.base_currency || lastBaseCurrency || "").toUpperCase() || "BASE";

        function hide() {
          tooltip.classList.remove("is-visible");
          dots.forEach((dot) => dot.classList.remove("is-highlighted"));
        }

        function show(index, event) {
          const point = points[index];
          if (!point) return;
          dots.forEach((dot, idx) => dot.classList.toggle("is-highlighted", idx === index));
          const formattedDate = formatDate(point.date);
          const dateLabel = formattedDate && formattedDate !== "—" ? formattedDate : `Day ${index + 1}`;
          const currencyLabel = useBaseCurrency
            ? baseLabel
            : (point.currency || history.prices?.[index]?.currency || "native").toString().toUpperCase();
          tooltip.textContent = `${dateLabel} · ${formatNumber(point.value)} ${currencyLabel}`;
          const containerRect = container.getBoundingClientRect();
          const relativeX = viewBox.width
            ? ((point.x - viewBox.x) / viewBox.width) * containerRect.width
            : point.x;
          const relativeY = viewBox.height
            ? ((point.y - viewBox.y) / viewBox.height) * containerRect.height
            : point.y;
          const sourceX = event ? event.clientX - containerRect.left : relativeX;
          const sourceY = event ? event.clientY - containerRect.top : relativeY;
          const left = Math.min(Math.max(sourceX + 12, 8), containerRect.width - 8);
          const top = Math.max(sourceY - 28, 8);
          tooltip.style.left = `${left}px`;
          tooltip.style.top = `${top}px`;
          tooltip.classList.add("is-visible");
        }

        svg.addEventListener("mousemove", (event) => {
          const rect = svg.getBoundingClientRect();
          const pointerX =
            rect.width > 0 ? ((event.clientX - rect.left) / rect.width) * viewBox.width + viewBox.x : event.clientX;
          let closestIndex = 0;
          let minDelta = Infinity;
          points.forEach((point, idx) => {
            const delta = Math.abs(point.x - pointerX);
            if (delta < minDelta) {
              minDelta = delta;
              closestIndex = idx;
            }
          });
          show(closestIndex, event);
        });

        svg.addEventListener("mouseleave", hide);
      }

      async function fetchPriceHistory(symbol, baseCurrency, windowDays = PRICE_HISTORY_WINDOW_DAYS) {
        const normalizedSymbol = (symbol || "").trim();
        if (!normalizedSymbol) {
          throw new Error("Symbol is required.");
        }
        const cacheKey = `${normalizedSymbol}:${(baseCurrency || "").toUpperCase()}:${windowDays}`;
        if (priceHistoryCache.has(cacheKey)) {
          return priceHistoryCache.get(cacheKey);
        }
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), REQUEST_TIMEOUT_MS);
        const fetchPromise = fetch(
          `/api/prices/history?symbol=${encodeURIComponent(normalizedSymbol)}&days=${windowDays}${
            baseCurrency ? `&base_currency=${encodeURIComponent(baseCurrency)}` : ""
          }`,
          { headers: authHeaders(), signal: controller.signal }
        )
          .then(async (response) => {
            if (!response.ok) {
              if (response.status === 401) {
                handleUnauthorized();
              }
              const detail = await response.json().catch(() => ({}));
              throw new Error(detail.detail || `History request failed with status ${response.status}`);
            }
            return response.json();
          })
          .finally(() => clearTimeout(timeout))
          .catch((error) => {
            priceHistoryCache.delete(cacheKey);
            throw error;
          });
        priceHistoryCache.set(cacheKey, fetchPromise);
        return fetchPromise;
      }

      async function renderSparklines(baseCurrency) {
        if (!ensureAuthenticated()) return;
        const elements = Array.from(dom.rowsBody.querySelectorAll("[data-sparkline-symbol]"));
        if (!elements.length) return;
        const jobs = elements.map(async (el) => {
          const symbol = el.dataset.sparklineSymbol;
          if (!symbol) return;
          renderSparklinePlaceholder(el, "Loading…", true);
          try {
            const history = await fetchPriceHistory(symbol, baseCurrency);
            if (!history || history.missing_fx) {
              renderSparklinePlaceholder(el, history && history.missing_fx ? "FX missing" : "No history", true);
              return;
            }
            const series = valuesForHistory(history, true).values;
            if (!series || series.length < 2) {
              renderSparklinePlaceholder(el, "No history", true);
              return;
            }
            const svg = buildSparkline(series);
            if (svg) {
              el.innerHTML = "";
              el.appendChild(svg);
              el.classList.add("sparkline--interactive");
              el.title = `${history.window_days}-day price trend`;
            } else {
              renderSparklinePlaceholder(el, "No chart", true);
            }
          } catch (error) {
            renderSparklinePlaceholder(el, "—", true);
            el.title = error.message || "Failed to load history.";
          }
        });
        await Promise.allSettled(jobs);
      }

      function renderRows(rows, baseCurrency, totalPortfolioValue) {
        if (!rows || !rows.length) {
          dom.rowsBody.innerHTML =
            `<tr><td colspan="${TABLE_COLUMN_COUNT}" class="empty-state">No positions in this snapshot.</td></tr>`;
          dom.rowsSummary.textContent = "0 positions.";
          return;
        }

        const portfolioTotal =
          typeof totalPortfolioValue === "number" && Number.isFinite(totalPortfolioValue)
            ? totalPortfolioValue
            : null;

        const groupMap = new Map();
        rows.forEach((row) => {
          if (!groupMap.has(row.symbol)) groupMap.set(row.symbol, []);
          groupMap.get(row.symbol).push(row);
        });

        const groups = Array.from(groupMap.entries()).map(([symbol, symbolRows]) => {
          const totalQuantity = symbolRows.reduce((sum, r) => sum + (r.quantity ?? 0), 0);
          const totalValue = symbolRows.reduce((sum, r) => {
            const value =
              r.value_base !== null && r.value_base !== undefined
                ? r.value_base
                : r.unit_price_base !== null &&
                  r.unit_price_base !== undefined &&
                  r.quantity !== null &&
                  r.quantity !== undefined
                ? r.unit_price_base * r.quantity
                : null;
            return value !== null && value !== undefined ? sum + value : sum;
          }, 0);
          const averagePrice = totalQuantity > 0 ? totalValue / totalQuantity : null;
          const percentOfPortfolio =
            portfolioTotal && portfolioTotal > 0 ? (totalValue / portfolioTotal) * PERCENT_SCALE : null;
          return { symbol, rows: symbolRows, totalQuantity, totalValue, averagePrice, percentOfPortfolio };
        });

        groups.sort((a, b) => (b.totalValue || 0) - (a.totalValue || 0));

        const fragment = document.createDocumentFragment();
        groups.forEach((group, index) => {
          const toggleId = `details-${index}`;
          const hasDetails = group.rows.length > 1;
          const summarySources = Array.from(
            new Set(group.rows.map((r) => r.source || r.market || "Unknown"))
          );

          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>
              <div>${group.symbol}</div>
              <div class="hint mono">${group.rows[0]?.asset_type ?? ""}</div>
            </td>
            <td>
              <div class="sparkline sparkline--muted" data-sparkline-symbol="${group.symbol}">
                <span class="sparkline__placeholder">Loading…</span>
              </div>
            </td>
            <td>
              ${summarySources.join(", ")}
              ${
                hasDetails
                  ? `<button class="toggle-button" type="button" data-toggle-details="${toggleId}" aria-expanded="false" aria-label="Toggle details">></button>`
                  : ""
              }
            </td>
            <td class="mono">${formatCurrency(group.averagePrice, baseCurrency)}</td>
            <td class="mono">${formatNumber(group.totalQuantity)}</td>
            <td class="mono">${formatCurrency(group.totalValue, baseCurrency)}</td>
            <td class="mono">${formatPercent(group.percentOfPortfolio)}</td>
          `;
          fragment.appendChild(tr);

          if (!hasDetails) {
            return;
          }

          const detailRow = document.createElement("tr");
          detailRow.id = toggleId;
          detailRow.className = "details-row is-hidden";
          const detailCell = document.createElement("td");
          detailCell.colSpan = TABLE_COLUMN_COUNT;

          const innerTable = document.createElement("table");
          innerTable.innerHTML = `
            <thead>
              <tr>
                <th>Source</th>
                <th>Unit price (USD)</th>
                <th>Quantity</th>
                <th>Value (USD)</th>
                <th>% of portfolio</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
              ${group.rows
                .map((row) => {
                  const unitPriceUsd = row.unit_price_base;
                  const quantity = row.quantity;
                  const valueUsd =
                    row.value_base !== null && row.value_base !== undefined
                      ? row.value_base
                      : unitPriceUsd !== null &&
                        unitPriceUsd !== undefined &&
                        quantity !== null &&
                        quantity !== undefined
                      ? unitPriceUsd * quantity
                      : null;
                  return `
                    <tr>
                      <td>${row.source ?? row.market ?? "—"}</td>
                      <td class="mono">${formatCurrency(unitPriceUsd, baseCurrency)}</td>
                      <td class="mono">${formatNumber(quantity)}</td>
                      <td class="mono">${formatCurrency(valueUsd, baseCurrency)}</td>
                      <td class="mono">${formatPercent(row.portfolio_share_pct)}</td>
                      <td>
                        ${
                          row.status
                            ? `<span class="badge" data-tone="${row.status === "ok" ? "ok" : "warning"}">${row.status}</span>`
                            : ""
                        }
                      </td>
                    </tr>
                  `;
                })
                .join("")}
            </tbody>
          `;

          detailCell.appendChild(innerTable);
          detailRow.appendChild(detailCell);
          fragment.appendChild(detailRow);
        });
        dom.rowsBody.replaceChildren(fragment);
        const summaryCurrency = baseCurrency || "base";
        dom.rowsSummary.textContent = `${rows.length} positions (grouped by symbol, sorted by ${summaryCurrency} value).`;
      }

      function renderHistoryModal() {
        const history = chartState.history;
        if (!history) return;
        const baseLabel = (history.base_currency || lastBaseCurrency || "").toUpperCase() || "BASE";
        const baseRequested = chartState.mode === "base";
        const useBase = baseRequested && !history.missing_fx;
        const series = valuesForHistory(history, useBase);
        const change =
          series.values.length >= 2 && series.values[0] !== 0
            ? ((series.values[series.values.length - 1] - series.values[0]) / series.values[0]) * PERCENT_SCALE
            : null;

        dom.historyModalTitle.textContent = `${chartState.symbol} price history`;
        const modeLabel = baseRequested
          ? history.missing_fx
            ? "Missing FX · showing native"
            : `Base ${baseLabel}`
          : "Native currency";
        dom.historyModalSubtitle.textContent = `${history.window_days}-day window · ${modeLabel}${
          change !== null && Number.isFinite(change) ? ` · ${formatPercent(change, 1)}` : ""
        }`;
        dom.historyModalAlert.classList.toggle("is-visible", baseRequested && history.missing_fx);

        const sources = Array.from(new Set((history.prices || []).map((p) => p.source || p.venue).filter(Boolean)));
        dom.historyModalSources.textContent = sources.length ? sources.join(", ") : "Source unknown";
        const toggleDisabled = history.missing_fx && !useBase;
        dom.historyModalToggle.textContent = toggleDisabled
          ? "Base FX missing"
          : baseRequested
          ? "Show native currency"
          : `Show ${baseLabel}`;
        dom.historyModalToggle.disabled = toggleDisabled;

        const target = dom.historyModalChart;
        target.innerHTML = "";
        if (series.values.length < 2) {
          target.innerHTML = '<div class="sparkline__placeholder">Not enough data for this chart.</div>';
          return;
        }
        const detailChart = buildDetailChart(
          series.values,
          series.dates,
          series.currencies,
          DETAIL_CHART_WIDTH,
          DETAIL_CHART_HEIGHT
        );
        if (detailChart && detailChart.svg) {
          target.appendChild(detailChart.svg);
          attachChartTooltip(target, detailChart.svg, detailChart.points, history, useBase);
        } else {
          target.innerHTML = '<div class="sparkline__placeholder">Chart unavailable.</div>';
        }
      }

      async function openHistoryModal(symbol) {
        if (!ensureAuthenticated()) return;
        const normalized = (symbol || "").trim();
        if (!normalized) return;
        chartState.symbol = normalized;
        chartState.history = null;
        chartState.mode = "base";
        dom.historyModal.classList.remove("is-hidden");
        dom.historyModalSubtitle.textContent = "Loading…";
        dom.historyModalChart.innerHTML = '<div class="sparkline__placeholder">Loading…</div>';
        dom.historyModalAlert.classList.remove("is-visible");
        dom.historyModalToggle.disabled = true;
        try {
          const history = await fetchPriceHistory(normalized, lastBaseCurrency || undefined);
          chartState.history = history;
          chartState.mode = history && history.missing_fx ? "native" : "base";
          renderHistoryModal();
        } catch (error) {
          dom.historyModalChart.innerHTML = `<div class="sparkline__placeholder">${
            error.message || "Failed to load history."
          }</div>`;
          dom.historyModalSubtitle.textContent = normalized;
        } finally {
          dom.historyModalToggle.disabled = false;
        }
      }

      function closeHistoryModal() {
        dom.historyModal.classList.add("is-hidden");
        chartState.symbol = null;
        chartState.history = null;
        chartState.mode = "base";
      }

      function authHeaders() {
        return hasValidToken() ? { Authorization: `Bearer ${authState.token}` } : {};
      }

      function handleUnauthorized() {
        clearAuthState("Session expired. Please log in again.");
        setStatus("Auth required", "error");
      }

      async function loadSnapshot(accountId) {
        if (!ensureAuthenticated()) {
          setFeedback("Please log in before loading a snapshot.", "error");
          return;
        }
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), REQUEST_TIMEOUT_MS);
        setStatus("Loading…", "loading");
        setFeedback("Fetching snapshot…");
        dom.submitButton.disabled = true;

        try {
          const response = await fetch(
            `/api/valuations/latest?account_id=${encodeURIComponent(accountId.trim())}`,
            { signal: controller.signal, headers: authHeaders() }
          );

          if (!response.ok) {
            if (response.status === 401) {
              handleUnauthorized();
            }
            const detail = await response.json().catch(() => ({}));
            throw new Error(detail.detail || `Request failed with status ${response.status}`);
          }

          const payload = await response.json();
          dom.snapshotDate.textContent = formatDate(payload.snapshot_dt);
          dom.computedTs.textContent = formatDateTime(payload.computed_ts);
          dom.accountLabel.textContent = payload.account_id;
          lastBaseCurrency = (payload.base_currency || payload.totals?.base_currency || "").toString().toUpperCase();
          priceHistoryCache.clear();
          dom.totalValue.textContent = formatCurrency(
            payload.totals?.total_value_base,
            payload.base_currency || payload.totals?.base_currency
          );
          dom.baseCurrency.textContent = `Base currency ${lastBaseCurrency || "—"}`;
          dom.positionsCount.textContent = payload.totals?.positions ?? "—";
          dom.okPositions.textContent = `OK positions ${payload.totals?.ok_positions ?? "—"}`;

          renderRows(payload.rows, lastBaseCurrency, payload.totals?.total_value_base);
          renderSparklines(lastBaseCurrency);
          setStatus("Snapshot ready", "ready");
          setFeedback(`Snapshot loaded for account ${payload.account_id}.`, "success");
          localStorage.setItem(STORAGE_KEY, accountId.trim());
        } catch (error) {
          if (error.name === "AbortError") {
            setFeedback("Request timed out. Try again.", "error");
          } else {
            setFeedback(error.message || "Failed to load snapshot.", "error");
          }
          setStatus("Error", "error");
          lastBaseCurrency = "";
          dom.rowsBody.innerHTML =
            `<tr><td colspan="${TABLE_COLUMN_COUNT}" class="empty-state">Could not load positions. Check the account id and try again.</td></tr>`;
          dom.rowsSummary.textContent = "Request failed.";
        } finally {
          dom.submitButton.disabled = false;
          clearTimeout(timeout);
        }
      }

      dom.form.addEventListener("submit", (event) => {
        event.preventDefault();
        const accountId = dom.accountInput.value.trim();
        if (!accountId) {
          setFeedback("Please enter an account id.", "error");
          return;
        }
        loadSnapshot(accountId);
      });

      dom.loginForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const username = dom.loginUsername.value.trim();
        const password = dom.loginPassword.value;
        if (!username || !password) {
          setLoginFeedback("Enter both username and password.", "error");
          return;
        }
        authenticate(username, password);
      });

      (function bootstrap() {
        const savedAccount = localStorage.getItem(STORAGE_KEY);
        if (savedAccount) {
          dom.accountInput.value = savedAccount;
          setFeedback("Account id restored. Log in and load the snapshot when ready.");
        } else {
          setFeedback("Log in, then enter an account id to get started.");
        }
      })();

      dom.rowsBody.addEventListener("click", (event) => {
        const sparkline = event.target.closest("[data-sparkline-symbol]");
        if (sparkline) {
          const symbol = sparkline.dataset.sparklineSymbol;
          if (symbol) {
            openHistoryModal(symbol);
          }
          return;
        }
        const button = event.target.closest("[data-toggle-details]");
        if (!button) return;
        const targetId = button.dataset.toggleDetails;
        const detailRow = document.getElementById(targetId);
        if (!detailRow) return;
        const isHidden = detailRow.classList.contains("is-hidden");
        detailRow.classList.toggle("is-hidden", !isHidden);
        button.setAttribute("aria-expanded", String(isHidden));
        button.textContent = isHidden ? "v" : ">";
      });

      dom.historyModalClose.addEventListener("click", closeHistoryModal);
      dom.historyModalToggle.addEventListener("click", () => {
        if (!chartState.history || dom.historyModalToggle.disabled) return;
        chartState.mode = chartState.mode === "base" ? "native" : "base";
        renderHistoryModal();
      });
      dom.historyModal.addEventListener("click", (event) => {
        if (event.target === dom.historyModal) {
          closeHistoryModal();
        }
      });
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && !dom.historyModal.classList.contains("is-hidden")) {
          closeHistoryModal();
        }
      });
    </script>
  </body>
</html>
